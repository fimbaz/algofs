#pragma version 5
txn RekeyTo
global ZeroAddress
!=
bnz retfail

txn OnCompletion
int DeleteApplication
==
bnz retok

txn OnCompletion
int UpdateApplication
==
bnz retok

txn ApplicationID
int 0
==
bnz retok

txna ApplicationArgs 0
byte "append"
==
callsub append
return
err
retok:
int 1
return
retfail:
int 0
return
append:
callsub find_end // pushes GLOB_VALUE[GLOB_INDEX],GLOB_INDEX onto stack
len
bnz skip_make_glob
dup
byte ""
app_global_put //GLOB_INDEX, ""
skip_make_glob:
txna ApplicationArgs 1
callsub doappend
pop
pop
retsub
//##
find_end:
int 0 
store 65 // GLOB_INDEX=0
int 0 // push so we can pop
check_next_var:
pop
int 0
load 65
itob
app_global_get_ex  // GLOB_EXISTS,GLOB_VALUE=app_global_get_ex bytes(GLOB_INDEX)
int 0
!= 
bz done    // if(!GLOB_EXISTS){ break; } else {
store 66  // set GLOB_VALUE
load 65   // increment GLOB_INDEX
int 1     // ^
+         // ^
store 65  // ^
b check_next_var
done:
store 66 // store len in 66
load 65  // store key in 65
itob
store 65
load 66
load 65
retsub
doappend: // START_INDEX STRING_TO_APPEND
int 0
store 68 // READ_POS (the position we're reading from in the source string)
swap
dup
app_global_get
len
int 128
swap
-
swap
app_global_get
load 68
swap           // START_INDEX BYTES_LEFT_IN_KEY
extract3         
concat
load 66 // TODO use the 'argument' instead of the 'global'
swap
app_global_put
retsub
err