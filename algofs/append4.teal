#pragma version 5
//PREAMBLE
txn RekeyTo
global ZeroAddress
!=
bnz retfail

txn OnCompletion
int DeleteApplication
==
bnz retok

txn OnCompletion
int UpdateApplication
==
bnz retok

txn ApplicationID
int 0
==
bnz retok
txna ApplicationArgs 0
byte "append"
==
bnz append
return
err

retok: // success/fail functions
int 1
return
retfail:
int 0
return
// END PREAMBLE

//APPEND: takes the second argument and appends it to the end of the globvar array
append:
//#1. find the end of the globvars
//#2. write the argument to the end of them
//1
int 0
next_key: // Stack: Int(NEXT_UNOCCUPIED_KEY)
int 0
swap
dup // Stack: APPLICATION_ID Int(NEXT_POSSIBLE_OCCUPIED_KEY) Int(NEXT_POSSIBLE_OCCUPIED_KEY)
cover 2  // Stack:  Int(NEXT_POBBILE_OCCUPIED_KEY) APPLICATION_ID Int(NEXT_POSSIBLE_OCCUPIED_KEY)
itob
app_global_get_ex
bz done_finding_keys
len
int 120
<
bnz done_finding_keys_with_data
int 1
+ // Stack: Int(NEXT_POSSIBLE_OCCUPIED_KEY)
b next_key
done_finding_keys:  // Stack: Int(NEXT_POSSIBLE_OCCUPIED_KEY)
pop
done_finding_keys_with_data:
itob // Stack: Bytes(LAST_POSSIBLE_OCCUPIED_KEY)
//2
dup
int 0
swap
app_global_get_ex
swap
pop
bnz append_data
dup
byte ""
app_global_put
append_data: // Stack: Bytes(LAST_OCCUPIED_KEY)
dup
app_global_get
len 
int 120
swap
-  // Bytes(LAST_OCCUPIED_KEY) Int(BYTES_FREE_IN_LAST_OCCUPIED_KEY) 
txna ApplicationArgs 1
len // Bytes(LAST_OCCUPIED_KEY) Int(BYTES_FREE_IN_LAST_OCCUPIED_KEY) Int(LENGTH_OF_STRING_TO_APPEND)
dig 1  // Bytes(LAST_OCCUPIED_KEY) Int(BYTES_FREE_IN_LAST_OCCUPIED_KEY) Int(LENGTH_OF_STRING_TO_APPEND) Int(BYTES_FREE_IN_LAST_OCCUPIED_KEY) Int(LENGTH_OF_STRING_TO_APPEND)
dig 1   // Bytes(LAST_OCCUPIED_KEY) Int(BYTES_FREE_IN_LAST_OCCUPIED_KEY) Int(LENGTH_OF_STRING_TO_APPEND) Int(BYTES_FREE_IN_LAST_OCCUPIED_KEY) Int(LENGTH_OF_STRING_TO_APPEND)
>  // Bytes(LAST_OCCUPIED_KEY) Int(BYTES_FREE_IN_LAST_OCCUPIED_KEY) Int(LENGTH_OF_STRING_TO_APPEND) Int(IS_APPENDED_STRING_SHORT)
select  // Bytes(LAST_OCCUPIED_KEY) Int(BYTES_TO_WRITE_IN_LAST_OCCUPIED_KEY)
dup
cover 2 // stash BYTES_TO_WRITE_IN_LAST_OCCUPIED_KEY
swap  //  Int(BYTES_TO_WRITE_IN_LAST_OCCUPIED_KEY) Bytes(LAST_OCCUPIED_KEY)
txna ApplicationArgs 1
int 0 // Int(BYTES_TO_WRITE_IN_LAST_OCCUPIED_KEY) Bytes(LAST_OCCUPIED_KEY)  Bytes(APPLICATION_ARG_1) Int(0)
uncover 3 // Bytes(LAST_OCCUPIED_KEY)  Bytes(APPLICATION_ARG_1) Int(0) Int(BYTES_TO_WRITE_IN_LAST_OCCUPIED_KEY)
dup
store 60 // 60(BYTES_WRITTEN)
extract3  // Bytes(LAST_OCCUPIED_KEY)  Bytes(FIRST_CHUNK_OF_STRING_TO_WRITE)
swap      // Bytes(FIRST_CHUNK_OF_STRING_TO_WRITE) Bytes(LAST_OCCUPIED_KEY)
dup     // Bytes(FIRST_CHUNK_OF_STRING_TO_WRITE) Bytes(LAST_OCCUPIED_KEY)
cover 2  // Bytes(LAST_OCCUPIED_KEY) Bytes(FIRST_CHUNK_OF_STRING_TO_WRITE) Bytes(LAST_OCCUPIED_KEY)
app_global_get   // Bytes(LAST_OCCUPIED_KEY) Bytes(FIRST_CHUNK_OF_STRING_TO_WRITE) Bytes(LAST_OCCUPIED_KEY_DATA)
swap    // Bytes(LAST_OCCUPIED_KEY) Bytes(LAST_OCCUPIED_KEY_DATA) Bytes(FIRST_CHUNK_OF_STRING_TO_WRITE)
concat // Bytes(LAST_OCCUPIED_KEY) Bytes(CHUNK_TO_WRITE)
swap
dup
cover 2  // Bytes(LAST_OCCUPIED_KEY) Bytes(CHUNK_TO_WRITE) Bytes(LAST_OCCUPIED_KEY)
swap
app_global_put // Int(BYTES_WRITTEN_IN_LAST_OCCUPIED_KEY)  Bytes(LAST_OCCUPIED_KEY)
swap
txna ApplicationArgs 1
len
store 61 // 61(TOTAL_BYTES_TO_WRITE)
load 61
load 60
-
swap
pop // Figure this out
pop
load 61
load 60
==  // TOTAL_BYTES_TO_WRITE == BYTES_WRITTEN
swap
pop
bnz all_done
store 72
append_next_chunk: // Bytes(LAST_OCCUPIED_KEY) Bytes(BYTES_LEFT)
load 72
btoi
int 1
+
itob // Bytes(NEXT_OCCUPIED_KEY)
dup
store 72
load 61 
load 60  // Int(TOTAL_BYTES_TO_WRITE) - Int(BYTES_WRITTEN)
-        // Bytes(NEXT_OCCUPIED_KEY) Int(BYTES_LEFT)
int 120  // Bytes(NEXT_OCCUPIED_KEY) Int(BYTES_LEFT) Int(120)
dig 1
dig 1   // Bytes(NEXT_OCCUPIED_KEY) Int(BYTES_LEFT) Int(120) Int(BYTES_LEFT) Int(120)
>
select // Bytes(NEXT_OCCUPIED_KEY) Int(BYTES_TO_WRITE)
dup
cover 2 // Int(BYTES_TO_WRITE) Bytes(NEXT_OCCUPIED_KEY) Int(BYTES_TO_WRITE)

txna ApplicationArgs 1
load 61
uncover 2   // Int(BYTES_TO_WRITE) Bytes(NEXT_OCCUPIED_KEY) Bytes(STRING_TO_APPEND) Int(BYTES_LEFT)  Int(BYTES_TO_WRITE)
// 130 (00c0): swap [120 AAAAAAAAAAM= apparg1 120 520]
 // Int(BYTES_TO_WRITE) Bytes(NEXT_OCCUPIED_KEY) Bytes(STRING_TO_APPEND) Int(BYTES_TO_WRITE) Int(BYTES_LEFT)
- // START_INDEX = TOTAL_BYTES_TO_WRITE  - BYTES_LEFT
dup  // Int(BYTES_TO_WRITE) Bytes(NEXT_OCCUPIED_KEY) Bytes(STRING_TO_APPEND) START_INDEX
cover 4 // Int(BYTES_TO_WRITE) Bytes(NEXT_OCCUPIED_KEY) Bytes(STRING_TO_APPEND) START_INDEX Int(BYTES_TO_zWRITE)
load 61
swap
-
dig 3
extract3 // STRING_TO_APPEND START_INDEX BYTES_TO_WRITE
app_global_put    // Int(BYTES_TO_WRITE)
store 60
load 72
btoi
int 1
+
itob
store 72
load 61
load 60
-
bnz append_next_chunk
//TODO: APPEND LAST CHUNK
all_done:
int 1
return