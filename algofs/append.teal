#pragma version 5
//PREAMBLE
txn RekeyTo
global ZeroAddress
!=
bnz retfail

txn OnCompletion
int DeleteApplication
==
bnz retok

txn OnCompletion
int UpdateApplication
==
bnz retok

txn ApplicationID
int 0
==
bz no_setup
byte "LastUsedSlot"
int 0
app_global_put
int 0
callsub small_int_as_byte
byte ""
app_global_put
int 1
return
no_setup:
txna ApplicationArgs 0
byte "append"
==
callsub is_owner
&&
bz dont_append
txna ApplicationArgs 1
callsub append
dont_append:
txna ApplicationArgs 0
byte "copy"
==
callsub is_owner
&&
bz dont_copyfrom
callsub copyfrom
dont_copyfrom:
return
err

is_owner:
txn Sender
global CreatorAddress
==
bz retfail
int 1
retsub


retok: // success/fail functions
int 1
return
retfail:
int 0
return
// END PREAMBLE
err
append: //# SCRATCH 1: current key, SCRATCH 2: bytes written
store 3 // String to append
byte "LastUsedSlot"
app_global_get
callsub small_int_as_byte
store 1
callsub bytes_left_in_key
append_body:
//callsub create_key_if_empty //# updates SCRATCH 1, returns bytes free in scratch slot
dup
bz inc_already
load 2
swap
callsub append_chunk_to_key // # updates SCRATCH 2
load 3
len
load 2
-
b skip
inc_already:
pop
int 1
skip:
callsub increment_key
int 127 // used to be supplied by a subroutine call above; TODO: just use scratch space
swap
bnz append_body
int 1
byte "LastUsedSlot"
load 1
btoi
int 1
-
app_global_put

retsub

increment_key:
load 1
btoi
int 1
+
callsub small_int_as_byte
store 1
retsub

bytes_left_in_key:
int 0
load 1
app_global_get_ex
bnz is_not_empty
int 127
retsub
is_not_empty:
len
int 127
swap
-
retsub

append_chunk_to_key: // # CHUNK_START BYTES_FREE_IN_CURRENT_KEY 
load 3
len
load 2
-
dup2
>
select
dup
load 2
+
store 2
cover 1
load 3
cover 2
swap
extract3
int 0
load 1
app_global_get_ex
bnz has_value
pop
byte ""
has_value:
swap
concat
load 1
swap
app_global_put
retsub
err
small_int_as_byte:
byte " "
int 0
uncover 2
setbyte
retsub
copyfrom:
int 0
app_params_get AppApprovalProgram
bz retfail
int 1
app_params_get AppApprovalProgram
bz retfail
==
bz retfail
byte "LastUsedSlot"
app_global_get
callsub small_int_as_byte
store 1
int 0
byte "CopySource"
app_global_get_ex
bnz continue_copy
pop
byte "CopySource"
txna Applications 1
app_global_put
byte "CopyDataLength"
int 1
callsub data_length
app_global_put
continue_copy:
byte "CopySource"
app_global_get
txna Applications 1
==
bz retfail
byte ""
store 4
copy_next:
byte "BytesCopied"
app_global_get
int 127
/
callsub small_int_as_byte
int 1
swap
app_global_get_ex
bz copyload_done // blank key in dest; all done.
dup
len
dup
int 127
==
bnz dont_terminate_yet
int 1
store 7
dont_terminate_yet:
byte "BytesCopied"
app_global_get
+
byte "BytesCopied"
swap
app_global_put
 //Stack: next value to copy
load 4
swap
concat
store 4
load 5
int 1
+
store 5
load 5
int 2 // iterations
>
load 7
||
bz copy_next
b max_iters
copyload_done:
pop
max_iters:
load 4
callsub append
bz done
done:
int 1
retsub
data_length: // #param: app array id
dup
byte "LastUsedSlot"
app_global_get_ex
pop
dup
int 1
+
int 127
*
swap
callsub small_int_as_byte
uncover 2
swap
app_global_get_ex
bz zerolen
len
int 127
swap
-
- // (LastUsedSlot*127 - (127 - len(Globals[LastUsedSlot]))) = Bytes in payload
retsub
zerolen:
int 127
-
retsub



