#pragma version 5
//PREAMBLE
txn RekeyTo
global ZeroAddress
!=
bnz retfail

txn OnCompletion
int DeleteApplication
==
bnz retok

txn OnCompletion
int UpdateApplication
==
bnz retok

txn ApplicationID
int 0
==
bnz retok

txna ApplicationArgs 0
byte "append"
==
callsub is_owner
&&
bnz append
b retfail
return
err

is_owner:
txn Sender
global CreatorAddress
==
bz retfail
int 1
retsub


retok: // success/fail functions
int 1
return
retfail:
int 0
return
// END PREAMBLE
err
append: //# SCRATCH 1: current key, SCRATCH 2: bytes written
byte "LastUsedSlot"
app_global_get
callsub small_int_as_byte
store 1
callsub bytes_left_in_key
append_body:
//callsub create_key_if_empty //# updates SCRATCH 1, returns bytes free in scratch slot
dup
bz inc_already
load 2
swap
callsub append_chunk_to_key // # updates SCRATCH 2
txna ApplicationArgs 1
len
load 2
-
b skip
inc_already:
pop
int 1
skip:
callsub increment_key
int 127 // used to be supplied by a subroutine call above; TODO: just use scratch space
swap
bnz append_body
int 1
byte "LastUsedSlot"
load 1
btoi
int 1
-
app_global_put

return

increment_key:
load 1
btoi
int 1
+
callsub small_int_as_byte
store 1
retsub

bytes_left_in_key:
int 0
load 1
app_global_get_ex
bnz is_not_empty
int 127
retsub
is_not_empty:
len
int 127
swap
-
retsub

append_chunk_to_key: // # CHUNK_START BYTES_FREE_IN_CURRENT_KEY 
txna ApplicationArgs 1
len
load 2
-
dup2
>
select
dup
load 2
+
store 2
cover 1
txna ApplicationArgs 1
cover 2
swap
extract3
int 0
load 1
app_global_get_ex
bnz has_value
pop
byte ""
has_value:
swap
concat
load 1
swap
app_global_put
retsub
err
small_int_as_byte:
byte " "
int 0
uncover 2
setbyte
retsub

